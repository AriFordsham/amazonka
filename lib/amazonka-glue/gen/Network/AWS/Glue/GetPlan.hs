{-# OPTIONS_GHC -fno-warn-deprecations #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.Glue.GetPlan
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Gets code to perform a specified mapping.
module Network.AWS.Glue.GetPlan
  ( -- * Creating a request
    GetPlan (..),
    mkGetPlan,

    -- ** Request lenses
    gpSinks,
    gpLocation,
    gpLanguage,
    gpAdditionalPlanOptionsMap,
    gpMapping,
    gpSource,

    -- * Destructuring the response
    GetPlanResponse (..),
    mkGetPlanResponse,

    -- ** Response lenses
    gpprsPythonScript,
    gpprsScalaCode,
    gpprsResponseStatus,
  )
where

import Network.AWS.Glue.Types
import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Lude
import qualified Network.AWS.Request as Req
import qualified Network.AWS.Response as Res

-- | /See:/ 'mkGetPlan' smart constructor.
data GetPlan = GetPlan'
  { sinks :: Lude.Maybe [CatalogEntry],
    location :: Lude.Maybe Location,
    language :: Lude.Maybe Language,
    additionalPlanOptionsMap ::
      Lude.Maybe (Lude.HashMap Lude.Text (Lude.Text)),
    mapping :: [MappingEntry],
    source :: CatalogEntry
  }
  deriving stock
    ( Lude.Eq,
      Lude.Ord,
      Lude.Read,
      Lude.Show,
      Lude.Generic
    )
  deriving anyclass (Lude.Hashable, Lude.NFData)

-- | Creates a value of 'GetPlan' with the minimum fields required to make a request.
--
-- * 'additionalPlanOptionsMap' - A map to hold additional optional key-value parameters.
--
-- Currently, these key-value pairs are supported:
--
--     * @inferSchema@ —  Specifies whether to set @inferSchema@ to true or false for the default script generated by an AWS Glue job. For example, to set @inferSchema@ to true, pass the following key value pair:
-- @--additional-plan-options-map '{"inferSchema":"true"}'@
--
--
-- * 'language' - The programming language of the code to perform the mapping.
-- * 'location' - The parameters for the mapping.
-- * 'mapping' - The list of mappings from a source table to target tables.
-- * 'sinks' - The target tables.
-- * 'source' - The source table.
mkGetPlan ::
  -- | 'source'
  CatalogEntry ->
  GetPlan
mkGetPlan pSource_ =
  GetPlan'
    { sinks = Lude.Nothing,
      location = Lude.Nothing,
      language = Lude.Nothing,
      additionalPlanOptionsMap = Lude.Nothing,
      mapping = Lude.mempty,
      source = pSource_
    }

-- | The target tables.
--
-- /Note:/ Consider using 'sinks' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpSinks :: Lens.Lens' GetPlan (Lude.Maybe [CatalogEntry])
gpSinks = Lens.lens (sinks :: GetPlan -> Lude.Maybe [CatalogEntry]) (\s a -> s {sinks = a} :: GetPlan)
{-# DEPRECATED gpSinks "Use generic-lens or generic-optics with 'sinks' instead." #-}

-- | The parameters for the mapping.
--
-- /Note:/ Consider using 'location' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpLocation :: Lens.Lens' GetPlan (Lude.Maybe Location)
gpLocation = Lens.lens (location :: GetPlan -> Lude.Maybe Location) (\s a -> s {location = a} :: GetPlan)
{-# DEPRECATED gpLocation "Use generic-lens or generic-optics with 'location' instead." #-}

-- | The programming language of the code to perform the mapping.
--
-- /Note:/ Consider using 'language' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpLanguage :: Lens.Lens' GetPlan (Lude.Maybe Language)
gpLanguage = Lens.lens (language :: GetPlan -> Lude.Maybe Language) (\s a -> s {language = a} :: GetPlan)
{-# DEPRECATED gpLanguage "Use generic-lens or generic-optics with 'language' instead." #-}

-- | A map to hold additional optional key-value parameters.
--
-- Currently, these key-value pairs are supported:
--
--     * @inferSchema@ —  Specifies whether to set @inferSchema@ to true or false for the default script generated by an AWS Glue job. For example, to set @inferSchema@ to true, pass the following key value pair:
-- @--additional-plan-options-map '{"inferSchema":"true"}'@
--
--
--
-- /Note:/ Consider using 'additionalPlanOptionsMap' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpAdditionalPlanOptionsMap :: Lens.Lens' GetPlan (Lude.Maybe (Lude.HashMap Lude.Text (Lude.Text)))
gpAdditionalPlanOptionsMap = Lens.lens (additionalPlanOptionsMap :: GetPlan -> Lude.Maybe (Lude.HashMap Lude.Text (Lude.Text))) (\s a -> s {additionalPlanOptionsMap = a} :: GetPlan)
{-# DEPRECATED gpAdditionalPlanOptionsMap "Use generic-lens or generic-optics with 'additionalPlanOptionsMap' instead." #-}

-- | The list of mappings from a source table to target tables.
--
-- /Note:/ Consider using 'mapping' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpMapping :: Lens.Lens' GetPlan [MappingEntry]
gpMapping = Lens.lens (mapping :: GetPlan -> [MappingEntry]) (\s a -> s {mapping = a} :: GetPlan)
{-# DEPRECATED gpMapping "Use generic-lens or generic-optics with 'mapping' instead." #-}

-- | The source table.
--
-- /Note:/ Consider using 'source' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpSource :: Lens.Lens' GetPlan CatalogEntry
gpSource = Lens.lens (source :: GetPlan -> CatalogEntry) (\s a -> s {source = a} :: GetPlan)
{-# DEPRECATED gpSource "Use generic-lens or generic-optics with 'source' instead." #-}

instance Lude.AWSRequest GetPlan where
  type Rs GetPlan = GetPlanResponse
  request = Req.postJSON glueService
  response =
    Res.receiveJSON
      ( \s h x ->
          GetPlanResponse'
            Lude.<$> (x Lude..?> "PythonScript")
            Lude.<*> (x Lude..?> "ScalaCode")
            Lude.<*> (Lude.pure (Lude.fromEnum s))
      )

instance Lude.ToHeaders GetPlan where
  toHeaders =
    Lude.const
      ( Lude.mconcat
          [ "X-Amz-Target" Lude.=# ("AWSGlue.GetPlan" :: Lude.ByteString),
            "Content-Type"
              Lude.=# ("application/x-amz-json-1.1" :: Lude.ByteString)
          ]
      )

instance Lude.ToJSON GetPlan where
  toJSON GetPlan' {..} =
    Lude.object
      ( Lude.catMaybes
          [ ("Sinks" Lude..=) Lude.<$> sinks,
            ("Location" Lude..=) Lude.<$> location,
            ("Language" Lude..=) Lude.<$> language,
            ("AdditionalPlanOptionsMap" Lude..=)
              Lude.<$> additionalPlanOptionsMap,
            Lude.Just ("Mapping" Lude..= mapping),
            Lude.Just ("Source" Lude..= source)
          ]
      )

instance Lude.ToPath GetPlan where
  toPath = Lude.const "/"

instance Lude.ToQuery GetPlan where
  toQuery = Lude.const Lude.mempty

-- | /See:/ 'mkGetPlanResponse' smart constructor.
data GetPlanResponse = GetPlanResponse'
  { pythonScript ::
      Lude.Maybe Lude.Text,
    scalaCode :: Lude.Maybe Lude.Text,
    responseStatus :: Lude.Int
  }
  deriving stock
    ( Lude.Eq,
      Lude.Ord,
      Lude.Read,
      Lude.Show,
      Lude.Generic
    )
  deriving anyclass (Lude.Hashable, Lude.NFData)

-- | Creates a value of 'GetPlanResponse' with the minimum fields required to make a request.
--
-- * 'pythonScript' - A Python script to perform the mapping.
-- * 'responseStatus' - The response status code.
-- * 'scalaCode' - The Scala code to perform the mapping.
mkGetPlanResponse ::
  -- | 'responseStatus'
  Lude.Int ->
  GetPlanResponse
mkGetPlanResponse pResponseStatus_ =
  GetPlanResponse'
    { pythonScript = Lude.Nothing,
      scalaCode = Lude.Nothing,
      responseStatus = pResponseStatus_
    }

-- | A Python script to perform the mapping.
--
-- /Note:/ Consider using 'pythonScript' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpprsPythonScript :: Lens.Lens' GetPlanResponse (Lude.Maybe Lude.Text)
gpprsPythonScript = Lens.lens (pythonScript :: GetPlanResponse -> Lude.Maybe Lude.Text) (\s a -> s {pythonScript = a} :: GetPlanResponse)
{-# DEPRECATED gpprsPythonScript "Use generic-lens or generic-optics with 'pythonScript' instead." #-}

-- | The Scala code to perform the mapping.
--
-- /Note:/ Consider using 'scalaCode' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpprsScalaCode :: Lens.Lens' GetPlanResponse (Lude.Maybe Lude.Text)
gpprsScalaCode = Lens.lens (scalaCode :: GetPlanResponse -> Lude.Maybe Lude.Text) (\s a -> s {scalaCode = a} :: GetPlanResponse)
{-# DEPRECATED gpprsScalaCode "Use generic-lens or generic-optics with 'scalaCode' instead." #-}

-- | The response status code.
--
-- /Note:/ Consider using 'responseStatus' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
gpprsResponseStatus :: Lens.Lens' GetPlanResponse Lude.Int
gpprsResponseStatus = Lens.lens (responseStatus :: GetPlanResponse -> Lude.Int) (\s a -> s {responseStatus = a} :: GetPlanResponse)
{-# DEPRECATED gpprsResponseStatus "Use generic-lens or generic-optics with 'responseStatus' instead." #-}
