{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-binds   #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -fno-warn-deprecations   #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.ApiGateway.PutMethod
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Add a method to an existing 'Resource' resource.
module Network.AWS.ApiGateway.PutMethod
    (
    -- * Creating a request
      PutMethod (..)
    , mkPutMethod
    -- ** Request lenses
    , pmRestApiId
    , pmResourceId
    , pmHttpMethod
    , pmAuthorizationType
    , pmApiKeyRequired
    , pmAuthorizationScopes
    , pmAuthorizerId
    , pmOperationName
    , pmRequestModels
    , pmRequestParameters
    , pmRequestValidatorId

     -- * Destructuring the response
    , Types.Method (..)
    , Types.mkMethod
    -- ** Response lenses
    , Types.mApiKeyRequired
    , Types.mAuthorizationScopes
    , Types.mAuthorizationType
    , Types.mAuthorizerId
    , Types.mHttpMethod
    , Types.mMethodIntegration
    , Types.mMethodResponses
    , Types.mOperationName
    , Types.mRequestModels
    , Types.mRequestParameters
    , Types.mRequestValidatorId
    ) where

import qualified Network.AWS.ApiGateway.Types as Types
import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Core
import qualified Network.AWS.Request as Request
import qualified Network.AWS.Response as Response

-- | Request to add a method to an existing 'Resource' resource.
--
-- /See:/ 'mkPutMethod' smart constructor.
data PutMethod = PutMethod'
  { restApiId :: Core.Text
    -- ^ [Required] The string identifier of the associated 'RestApi' .
  , resourceId :: Core.Text
    -- ^ [Required] The 'Resource' identifier for the new 'Method' resource.
  , httpMethod :: Core.Text
    -- ^ [Required] Specifies the method request's HTTP method type.
  , authorizationType :: Core.Text
    -- ^ [Required] The method's authorization type. Valid values are @NONE@ for open access, @AWS_IAM@ for using AWS IAM permissions, @CUSTOM@ for using a custom authorizer, or @COGNITO_USER_POOLS@ for using a Cognito user pool.
  , apiKeyRequired :: Core.Maybe Core.Bool
    -- ^ Specifies whether the method required a valid 'ApiKey' .
  , authorizationScopes :: Core.Maybe [Core.Text]
    -- ^ A list of authorization scopes configured on the method. The scopes are used with a @COGNITO_USER_POOLS@ authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
  , authorizerId :: Core.Maybe Core.Text
    -- ^ Specifies the identifier of an 'Authorizer' to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
  , operationName :: Core.Maybe Core.Text
    -- ^ A human-friendly operation identifier for the method. For example, you can assign the @operationName@ of @ListPets@ for the @GET /pets@ method in the @PetStore@ example.
  , requestModels :: Core.Maybe (Core.HashMap Core.Text Core.Text)
    -- ^ Specifies the 'Model' resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a 'Model' name as the value.
  , requestParameters :: Core.Maybe (Core.HashMap Core.Text Core.Bool)
    -- ^ A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of @method.request.{location}.{name}@ , where @location@ is @querystring@ , @path@ , or @header@ and @name@ is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (@true@ ) or optional (@false@ ). The method request parameter names defined here are available in 'Integration' to be mapped to integration request parameters or body-mapping templates.
  , requestValidatorId :: Core.Maybe Core.Text
    -- ^ The identifier of a 'RequestValidator' for validating the method request.
  }
  deriving stock (Core.Eq, Core.Ord, Core.Read, Core.Show, Core.Generic)
  deriving anyclass (Core.Hashable, Core.NFData)

-- | Creates a 'PutMethod' value with any optional fields omitted.
mkPutMethod
    :: Core.Text -- ^ 'restApiId'
    -> Core.Text -- ^ 'resourceId'
    -> Core.Text -- ^ 'httpMethod'
    -> Core.Text -- ^ 'authorizationType'
    -> PutMethod
mkPutMethod restApiId resourceId httpMethod authorizationType
  = PutMethod'{restApiId, resourceId, httpMethod, authorizationType,
               apiKeyRequired = Core.Nothing, authorizationScopes = Core.Nothing,
               authorizerId = Core.Nothing, operationName = Core.Nothing,
               requestModels = Core.Nothing, requestParameters = Core.Nothing,
               requestValidatorId = Core.Nothing}

-- | [Required] The string identifier of the associated 'RestApi' .
--
-- /Note:/ Consider using 'restApiId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmRestApiId :: Lens.Lens' PutMethod Core.Text
pmRestApiId = Lens.field @"restApiId"
{-# INLINEABLE pmRestApiId #-}
{-# DEPRECATED restApiId "Use generic-lens or generic-optics with 'restApiId' instead"  #-}

-- | [Required] The 'Resource' identifier for the new 'Method' resource.
--
-- /Note:/ Consider using 'resourceId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmResourceId :: Lens.Lens' PutMethod Core.Text
pmResourceId = Lens.field @"resourceId"
{-# INLINEABLE pmResourceId #-}
{-# DEPRECATED resourceId "Use generic-lens or generic-optics with 'resourceId' instead"  #-}

-- | [Required] Specifies the method request's HTTP method type.
--
-- /Note:/ Consider using 'httpMethod' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmHttpMethod :: Lens.Lens' PutMethod Core.Text
pmHttpMethod = Lens.field @"httpMethod"
{-# INLINEABLE pmHttpMethod #-}
{-# DEPRECATED httpMethod "Use generic-lens or generic-optics with 'httpMethod' instead"  #-}

-- | [Required] The method's authorization type. Valid values are @NONE@ for open access, @AWS_IAM@ for using AWS IAM permissions, @CUSTOM@ for using a custom authorizer, or @COGNITO_USER_POOLS@ for using a Cognito user pool.
--
-- /Note:/ Consider using 'authorizationType' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmAuthorizationType :: Lens.Lens' PutMethod Core.Text
pmAuthorizationType = Lens.field @"authorizationType"
{-# INLINEABLE pmAuthorizationType #-}
{-# DEPRECATED authorizationType "Use generic-lens or generic-optics with 'authorizationType' instead"  #-}

-- | Specifies whether the method required a valid 'ApiKey' .
--
-- /Note:/ Consider using 'apiKeyRequired' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmApiKeyRequired :: Lens.Lens' PutMethod (Core.Maybe Core.Bool)
pmApiKeyRequired = Lens.field @"apiKeyRequired"
{-# INLINEABLE pmApiKeyRequired #-}
{-# DEPRECATED apiKeyRequired "Use generic-lens or generic-optics with 'apiKeyRequired' instead"  #-}

-- | A list of authorization scopes configured on the method. The scopes are used with a @COGNITO_USER_POOLS@ authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
--
-- /Note:/ Consider using 'authorizationScopes' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmAuthorizationScopes :: Lens.Lens' PutMethod (Core.Maybe [Core.Text])
pmAuthorizationScopes = Lens.field @"authorizationScopes"
{-# INLINEABLE pmAuthorizationScopes #-}
{-# DEPRECATED authorizationScopes "Use generic-lens or generic-optics with 'authorizationScopes' instead"  #-}

-- | Specifies the identifier of an 'Authorizer' to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
--
-- /Note:/ Consider using 'authorizerId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmAuthorizerId :: Lens.Lens' PutMethod (Core.Maybe Core.Text)
pmAuthorizerId = Lens.field @"authorizerId"
{-# INLINEABLE pmAuthorizerId #-}
{-# DEPRECATED authorizerId "Use generic-lens or generic-optics with 'authorizerId' instead"  #-}

-- | A human-friendly operation identifier for the method. For example, you can assign the @operationName@ of @ListPets@ for the @GET /pets@ method in the @PetStore@ example.
--
-- /Note:/ Consider using 'operationName' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmOperationName :: Lens.Lens' PutMethod (Core.Maybe Core.Text)
pmOperationName = Lens.field @"operationName"
{-# INLINEABLE pmOperationName #-}
{-# DEPRECATED operationName "Use generic-lens or generic-optics with 'operationName' instead"  #-}

-- | Specifies the 'Model' resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a 'Model' name as the value.
--
-- /Note:/ Consider using 'requestModels' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmRequestModels :: Lens.Lens' PutMethod (Core.Maybe (Core.HashMap Core.Text Core.Text))
pmRequestModels = Lens.field @"requestModels"
{-# INLINEABLE pmRequestModels #-}
{-# DEPRECATED requestModels "Use generic-lens or generic-optics with 'requestModels' instead"  #-}

-- | A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of @method.request.{location}.{name}@ , where @location@ is @querystring@ , @path@ , or @header@ and @name@ is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (@true@ ) or optional (@false@ ). The method request parameter names defined here are available in 'Integration' to be mapped to integration request parameters or body-mapping templates.
--
-- /Note:/ Consider using 'requestParameters' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmRequestParameters :: Lens.Lens' PutMethod (Core.Maybe (Core.HashMap Core.Text Core.Bool))
pmRequestParameters = Lens.field @"requestParameters"
{-# INLINEABLE pmRequestParameters #-}
{-# DEPRECATED requestParameters "Use generic-lens or generic-optics with 'requestParameters' instead"  #-}

-- | The identifier of a 'RequestValidator' for validating the method request.
--
-- /Note:/ Consider using 'requestValidatorId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
pmRequestValidatorId :: Lens.Lens' PutMethod (Core.Maybe Core.Text)
pmRequestValidatorId = Lens.field @"requestValidatorId"
{-# INLINEABLE pmRequestValidatorId #-}
{-# DEPRECATED requestValidatorId "Use generic-lens or generic-optics with 'requestValidatorId' instead"  #-}

instance Core.ToQuery PutMethod where
        toQuery _ = Core.pure Core.mempty

instance Core.ToHeaders PutMethod where
        toHeaders PutMethod{..} = Core.pure ("Accept", "application/json")

instance Core.FromJSON PutMethod where
        toJSON PutMethod{..}
          = Core.object
              (Core.catMaybes
                 [Core.Just ("authorizationType" Core..= authorizationType),
                  ("apiKeyRequired" Core..=) Core.<$> apiKeyRequired,
                  ("authorizationScopes" Core..=) Core.<$> authorizationScopes,
                  ("authorizerId" Core..=) Core.<$> authorizerId,
                  ("operationName" Core..=) Core.<$> operationName,
                  ("requestModels" Core..=) Core.<$> requestModels,
                  ("requestParameters" Core..=) Core.<$> requestParameters,
                  ("requestValidatorId" Core..=) Core.<$> requestValidatorId])

instance Core.AWSRequest PutMethod where
        type Rs PutMethod = Types.Method
        toRequest x@Core.Request{..}
          = Core.Request{Core._rqService = Types.mkServiceConfig,
                         Core._rqMethod = Request.PUT,
                         Core._rqPath =
                           "/restapis/" Core.<> Core.toText restApiId Core.<> "/resources/"
                             Core.<> Core.toText resourceId
                             Core.<> "/methods/"
                             Core.<> Core.toText httpMethod,
                         Core._rqQuery = Core.toQuery x, Core._rqHeaders = Core.toHeaders x,
                         Core._rqBody = Core.toJSONBody x}
        
        {-# INLINE toRequest #-}
        parseResponse
          = Response.receiveJSON (\ s h x -> Core.eitherParseJSON x)
        
        {-# INLINE parseResponse #-}
