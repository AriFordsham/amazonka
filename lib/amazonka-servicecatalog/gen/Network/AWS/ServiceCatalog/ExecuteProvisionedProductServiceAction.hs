{-# OPTIONS_GHC -fno-warn-deprecations #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.ServiceCatalog.ExecuteProvisionedProductServiceAction
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Executes a self-service action against a provisioned product.
module Network.AWS.ServiceCatalog.ExecuteProvisionedProductServiceAction
  ( -- * Creating a request
    ExecuteProvisionedProductServiceAction (..),
    mkExecuteProvisionedProductServiceAction,

    -- ** Request lenses
    eppsaAcceptLanguage,
    eppsaParameters,
    eppsaProvisionedProductId,
    eppsaServiceActionId,
    eppsaExecuteToken,

    -- * Destructuring the response
    ExecuteProvisionedProductServiceActionResponse (..),
    mkExecuteProvisionedProductServiceActionResponse,

    -- ** Response lenses
    eppsarsRecordDetail,
    eppsarsResponseStatus,
  )
where

import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Lude
import qualified Network.AWS.Request as Req
import qualified Network.AWS.Response as Res
import Network.AWS.ServiceCatalog.Types

-- | /See:/ 'mkExecuteProvisionedProductServiceAction' smart constructor.
data ExecuteProvisionedProductServiceAction = ExecuteProvisionedProductServiceAction'
  { acceptLanguage ::
      Lude.Maybe
        Lude.Text,
    parameters ::
      Lude.Maybe
        ( Lude.HashMap
            Lude.Text
            ([Lude.Text])
        ),
    provisionedProductId ::
      Lude.Text,
    serviceActionId ::
      Lude.Text,
    executeToken ::
      Lude.Text
  }
  deriving stock
    ( Lude.Eq,
      Lude.Ord,
      Lude.Read,
      Lude.Show,
      Lude.Generic
    )
  deriving anyclass (Lude.Hashable, Lude.NFData)

-- | Creates a value of 'ExecuteProvisionedProductServiceAction' with the minimum fields required to make a request.
--
-- * 'acceptLanguage' - The language code.
--
--
--     * @en@ - English (default)
--
--
--     * @jp@ - Japanese
--
--
--     * @zh@ - Chinese
--
--
-- * 'executeToken' - An idempotency token that uniquely identifies the execute request.
-- * 'parameters' - A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as @TARGET@ , the provided value will override the default value generated by AWS Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for any special parameters such as @TARGET@ .
-- * 'provisionedProductId' - The identifier of the provisioned product.
-- * 'serviceActionId' - The self-service action identifier. For example, @act-fs7abcd89wxyz@ .
mkExecuteProvisionedProductServiceAction ::
  -- | 'provisionedProductId'
  Lude.Text ->
  -- | 'serviceActionId'
  Lude.Text ->
  -- | 'executeToken'
  Lude.Text ->
  ExecuteProvisionedProductServiceAction
mkExecuteProvisionedProductServiceAction
  pProvisionedProductId_
  pServiceActionId_
  pExecuteToken_ =
    ExecuteProvisionedProductServiceAction'
      { acceptLanguage =
          Lude.Nothing,
        parameters = Lude.Nothing,
        provisionedProductId = pProvisionedProductId_,
        serviceActionId = pServiceActionId_,
        executeToken = pExecuteToken_
      }

-- | The language code.
--
--
--     * @en@ - English (default)
--
--
--     * @jp@ - Japanese
--
--
--     * @zh@ - Chinese
--
--
--
-- /Note:/ Consider using 'acceptLanguage' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsaAcceptLanguage :: Lens.Lens' ExecuteProvisionedProductServiceAction (Lude.Maybe Lude.Text)
eppsaAcceptLanguage = Lens.lens (acceptLanguage :: ExecuteProvisionedProductServiceAction -> Lude.Maybe Lude.Text) (\s a -> s {acceptLanguage = a} :: ExecuteProvisionedProductServiceAction)
{-# DEPRECATED eppsaAcceptLanguage "Use generic-lens or generic-optics with 'acceptLanguage' instead." #-}

-- | A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as @TARGET@ , the provided value will override the default value generated by AWS Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for any special parameters such as @TARGET@ .
--
-- /Note:/ Consider using 'parameters' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsaParameters :: Lens.Lens' ExecuteProvisionedProductServiceAction (Lude.Maybe (Lude.HashMap Lude.Text ([Lude.Text])))
eppsaParameters = Lens.lens (parameters :: ExecuteProvisionedProductServiceAction -> Lude.Maybe (Lude.HashMap Lude.Text ([Lude.Text]))) (\s a -> s {parameters = a} :: ExecuteProvisionedProductServiceAction)
{-# DEPRECATED eppsaParameters "Use generic-lens or generic-optics with 'parameters' instead." #-}

-- | The identifier of the provisioned product.
--
-- /Note:/ Consider using 'provisionedProductId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsaProvisionedProductId :: Lens.Lens' ExecuteProvisionedProductServiceAction Lude.Text
eppsaProvisionedProductId = Lens.lens (provisionedProductId :: ExecuteProvisionedProductServiceAction -> Lude.Text) (\s a -> s {provisionedProductId = a} :: ExecuteProvisionedProductServiceAction)
{-# DEPRECATED eppsaProvisionedProductId "Use generic-lens or generic-optics with 'provisionedProductId' instead." #-}

-- | The self-service action identifier. For example, @act-fs7abcd89wxyz@ .
--
-- /Note:/ Consider using 'serviceActionId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsaServiceActionId :: Lens.Lens' ExecuteProvisionedProductServiceAction Lude.Text
eppsaServiceActionId = Lens.lens (serviceActionId :: ExecuteProvisionedProductServiceAction -> Lude.Text) (\s a -> s {serviceActionId = a} :: ExecuteProvisionedProductServiceAction)
{-# DEPRECATED eppsaServiceActionId "Use generic-lens or generic-optics with 'serviceActionId' instead." #-}

-- | An idempotency token that uniquely identifies the execute request.
--
-- /Note:/ Consider using 'executeToken' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsaExecuteToken :: Lens.Lens' ExecuteProvisionedProductServiceAction Lude.Text
eppsaExecuteToken = Lens.lens (executeToken :: ExecuteProvisionedProductServiceAction -> Lude.Text) (\s a -> s {executeToken = a} :: ExecuteProvisionedProductServiceAction)
{-# DEPRECATED eppsaExecuteToken "Use generic-lens or generic-optics with 'executeToken' instead." #-}

instance Lude.AWSRequest ExecuteProvisionedProductServiceAction where
  type
    Rs ExecuteProvisionedProductServiceAction =
      ExecuteProvisionedProductServiceActionResponse
  request = Req.postJSON serviceCatalogService
  response =
    Res.receiveJSON
      ( \s h x ->
          ExecuteProvisionedProductServiceActionResponse'
            Lude.<$> (x Lude..?> "RecordDetail") Lude.<*> (Lude.pure (Lude.fromEnum s))
      )

instance Lude.ToHeaders ExecuteProvisionedProductServiceAction where
  toHeaders =
    Lude.const
      ( Lude.mconcat
          [ "X-Amz-Target"
              Lude.=# ( "AWS242ServiceCatalogService.ExecuteProvisionedProductServiceAction" ::
                          Lude.ByteString
                      ),
            "Content-Type"
              Lude.=# ("application/x-amz-json-1.1" :: Lude.ByteString)
          ]
      )

instance Lude.ToJSON ExecuteProvisionedProductServiceAction where
  toJSON ExecuteProvisionedProductServiceAction' {..} =
    Lude.object
      ( Lude.catMaybes
          [ ("AcceptLanguage" Lude..=) Lude.<$> acceptLanguage,
            ("Parameters" Lude..=) Lude.<$> parameters,
            Lude.Just ("ProvisionedProductId" Lude..= provisionedProductId),
            Lude.Just ("ServiceActionId" Lude..= serviceActionId),
            Lude.Just ("ExecuteToken" Lude..= executeToken)
          ]
      )

instance Lude.ToPath ExecuteProvisionedProductServiceAction where
  toPath = Lude.const "/"

instance Lude.ToQuery ExecuteProvisionedProductServiceAction where
  toQuery = Lude.const Lude.mempty

-- | /See:/ 'mkExecuteProvisionedProductServiceActionResponse' smart constructor.
data ExecuteProvisionedProductServiceActionResponse = ExecuteProvisionedProductServiceActionResponse'
  { recordDetail ::
      Lude.Maybe
        RecordDetail,
    responseStatus ::
      Lude.Int
  }
  deriving stock
    ( Lude.Eq,
      Lude.Ord,
      Lude.Read,
      Lude.Show,
      Lude.Generic
    )
  deriving anyclass
    ( Lude.Hashable,
      Lude.NFData
    )

-- | Creates a value of 'ExecuteProvisionedProductServiceActionResponse' with the minimum fields required to make a request.
--
-- * 'recordDetail' - An object containing detailed information about the result of provisioning the product.
-- * 'responseStatus' - The response status code.
mkExecuteProvisionedProductServiceActionResponse ::
  -- | 'responseStatus'
  Lude.Int ->
  ExecuteProvisionedProductServiceActionResponse
mkExecuteProvisionedProductServiceActionResponse pResponseStatus_ =
  ExecuteProvisionedProductServiceActionResponse'
    { recordDetail =
        Lude.Nothing,
      responseStatus = pResponseStatus_
    }

-- | An object containing detailed information about the result of provisioning the product.
--
-- /Note:/ Consider using 'recordDetail' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsarsRecordDetail :: Lens.Lens' ExecuteProvisionedProductServiceActionResponse (Lude.Maybe RecordDetail)
eppsarsRecordDetail = Lens.lens (recordDetail :: ExecuteProvisionedProductServiceActionResponse -> Lude.Maybe RecordDetail) (\s a -> s {recordDetail = a} :: ExecuteProvisionedProductServiceActionResponse)
{-# DEPRECATED eppsarsRecordDetail "Use generic-lens or generic-optics with 'recordDetail' instead." #-}

-- | The response status code.
--
-- /Note:/ Consider using 'responseStatus' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
eppsarsResponseStatus :: Lens.Lens' ExecuteProvisionedProductServiceActionResponse Lude.Int
eppsarsResponseStatus = Lens.lens (responseStatus :: ExecuteProvisionedProductServiceActionResponse -> Lude.Int) (\s a -> s {responseStatus = a} :: ExecuteProvisionedProductServiceActionResponse)
{-# DEPRECATED eppsarsResponseStatus "Use generic-lens or generic-optics with 'responseStatus' instead." #-}
