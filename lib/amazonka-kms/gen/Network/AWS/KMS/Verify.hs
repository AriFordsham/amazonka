{-# OPTIONS_GHC -fno-warn-deprecations #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.KMS.Verify
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Verifies a digital signature that was generated by the 'Sign' operation.
--
--
-- Verification confirms that an authorized user signed the message with the specified CMK and signing algorithm, and the message hasn't changed since it was signed. If the signature is verified, the value of the @SignatureValid@ field in the response is @True@ . If the signature verification fails, the @Verify@ operation fails with an @KMSInvalidSignatureException@ exception.
-- A digital signature is generated by using the private key in an asymmetric CMK. The signature is verified by using the public key in the same asymmetric CMK. For information about symmetric and asymmetric CMKs, see <https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html Using Symmetric and Asymmetric CMKs> in the /AWS Key Management Service Developer Guide/ .
-- To verify a digital signature, you can use the @Verify@ operation. Specify the same asymmetric CMK, message, and signing algorithm that were used to produce the signature.
-- You can also verify the digital signature by using the public key of the CMK outside of AWS KMS. Use the 'GetPublicKey' operation to download the public key in the asymmetric CMK and then use the public key to verify the signature outside of AWS KMS. The advantage of using the @Verify@ operation is that it is performed within AWS KMS. As a result, it's easy to call, the operation is performed within the FIPS boundary, it is logged in AWS CloudTrail, and you can use key policy and IAM policy to determine who is authorized to use the CMK to verify signatures.
-- The CMK that you use for this operation must be in a compatible key state. For details, see <https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html How Key State Affects Use of a Customer Master Key> in the /AWS Key Management Service Developer Guide/ .
module Network.AWS.KMS.Verify
  ( -- * Creating a request
    Verify (..),
    mkVerify,

    -- ** Request lenses
    vKeyId,
    vMessage,
    vSignature,
    vSigningAlgorithm,
    vGrantTokens,
    vMessageType,

    -- * Destructuring the response
    VerifyResponse (..),
    mkVerifyResponse,

    -- ** Response lenses
    vrrsKeyId,
    vrrsSignatureValid,
    vrrsSigningAlgorithm,
    vrrsResponseStatus,
  )
where

import qualified Network.AWS.KMS.Types as Types
import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Core
import qualified Network.AWS.Request as Request
import qualified Network.AWS.Response as Response

-- | /See:/ 'mkVerify' smart constructor.
data Verify = Verify'
  { -- | Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
    --
    -- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
    -- For example:
    --
    --     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@
    --
    --
    --     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@
    --
    --
    --     * Alias name: @alias/ExampleAlias@
    --
    --
    --     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@
    --
    --
    -- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
    keyId :: Types.KeyIdType,
    -- | Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
    --
    -- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.
    message :: Core.Sensitive Core.Base64,
    -- | The signature that the @Sign@ operation generated.
    signature :: Core.Base64,
    -- | The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
    signingAlgorithm :: Types.SigningAlgorithmSpec,
    -- | A list of grant tokens.
    --
    -- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
    grantTokens :: Core.Maybe [Types.GrantTokenType],
    -- | Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
    --
    -- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
    messageType :: Core.Maybe Types.MessageType
  }
  deriving stock (Core.Eq, Core.Ord, Core.Show, Core.Generic)
  deriving anyclass (Core.Hashable, Core.NFData)

-- | Creates a 'Verify' value with any optional fields omitted.
mkVerify ::
  -- | 'keyId'
  Types.KeyIdType ->
  -- | 'message'
  Core.Sensitive Core.Base64 ->
  -- | 'signature'
  Core.Base64 ->
  -- | 'signingAlgorithm'
  Types.SigningAlgorithmSpec ->
  Verify
mkVerify keyId message signature signingAlgorithm =
  Verify'
    { keyId,
      message,
      signature,
      signingAlgorithm,
      grantTokens = Core.Nothing,
      messageType = Core.Nothing
    }

-- | Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
--
-- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
-- For example:
--
--     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Alias name: @alias/ExampleAlias@
--
--
--     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@
--
--
-- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vKeyId :: Lens.Lens' Verify Types.KeyIdType
vKeyId = Lens.field @"keyId"
{-# DEPRECATED vKeyId "Use generic-lens or generic-optics with 'keyId' instead." #-}

-- | Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
--
-- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'message' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessage :: Lens.Lens' Verify (Core.Sensitive Core.Base64)
vMessage = Lens.field @"message"
{-# DEPRECATED vMessage "Use generic-lens or generic-optics with 'message' instead." #-}

-- | The signature that the @Sign@ operation generated.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'signature' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSignature :: Lens.Lens' Verify Core.Base64
vSignature = Lens.field @"signature"
{-# DEPRECATED vSignature "Use generic-lens or generic-optics with 'signature' instead." #-}

-- | The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSigningAlgorithm :: Lens.Lens' Verify Types.SigningAlgorithmSpec
vSigningAlgorithm = Lens.field @"signingAlgorithm"
{-# DEPRECATED vSigningAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead." #-}

-- | A list of grant tokens.
--
-- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
--
-- /Note:/ Consider using 'grantTokens' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vGrantTokens :: Lens.Lens' Verify (Core.Maybe [Types.GrantTokenType])
vGrantTokens = Lens.field @"grantTokens"
{-# DEPRECATED vGrantTokens "Use generic-lens or generic-optics with 'grantTokens' instead." #-}

-- | Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
--
-- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
--
-- /Note:/ Consider using 'messageType' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessageType :: Lens.Lens' Verify (Core.Maybe Types.MessageType)
vMessageType = Lens.field @"messageType"
{-# DEPRECATED vMessageType "Use generic-lens or generic-optics with 'messageType' instead." #-}

instance Core.FromJSON Verify where
  toJSON Verify {..} =
    Core.object
      ( Core.catMaybes
          [ Core.Just ("KeyId" Core..= keyId),
            Core.Just ("Message" Core..= message),
            Core.Just ("Signature" Core..= signature),
            Core.Just ("SigningAlgorithm" Core..= signingAlgorithm),
            ("GrantTokens" Core..=) Core.<$> grantTokens,
            ("MessageType" Core..=) Core.<$> messageType
          ]
      )

instance Core.AWSRequest Verify where
  type Rs Verify = VerifyResponse
  request x@Core.Request {..} =
    Core.Request
      { Core._rqService = Types.mkServiceConfig,
        Core._rqMethod = Request.POST,
        Core._rqPath = Core.rawPath "/",
        Core._rqQuery = Core.mempty,
        Core._rqHeaders =
          Core.pure ("X-Amz-Target", "TrentService.Verify")
            Core.<> (Core.pure ("Content-Type", "application/x-amz-json-1.1")),
        Core._rqBody = Core.toJSONBody x
      }
  response =
    Response.receiveJSON
      ( \s h x ->
          VerifyResponse'
            Core.<$> (x Core..:? "KeyId")
            Core.<*> (x Core..:? "SignatureValid")
            Core.<*> (x Core..:? "SigningAlgorithm")
            Core.<*> (Core.pure (Core.fromEnum s))
      )

-- | /See:/ 'mkVerifyResponse' smart constructor.
data VerifyResponse = VerifyResponse'
  { -- | The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
    keyId :: Core.Maybe Types.KeyId,
    -- | A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception.
    signatureValid :: Core.Maybe Core.Bool,
    -- | The signing algorithm that was used to verify the signature.
    signingAlgorithm :: Core.Maybe Types.SigningAlgorithmSpec,
    -- | The response status code.
    responseStatus :: Core.Int
  }
  deriving stock (Core.Eq, Core.Ord, Core.Read, Core.Show, Core.Generic)
  deriving anyclass (Core.Hashable, Core.NFData)

-- | Creates a 'VerifyResponse' value with any optional fields omitted.
mkVerifyResponse ::
  -- | 'responseStatus'
  Core.Int ->
  VerifyResponse
mkVerifyResponse responseStatus =
  VerifyResponse'
    { keyId = Core.Nothing,
      signatureValid = Core.Nothing,
      signingAlgorithm = Core.Nothing,
      responseStatus
    }

-- | The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsKeyId :: Lens.Lens' VerifyResponse (Core.Maybe Types.KeyId)
vrrsKeyId = Lens.field @"keyId"
{-# DEPRECATED vrrsKeyId "Use generic-lens or generic-optics with 'keyId' instead." #-}

-- | A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception.
--
-- /Note:/ Consider using 'signatureValid' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsSignatureValid :: Lens.Lens' VerifyResponse (Core.Maybe Core.Bool)
vrrsSignatureValid = Lens.field @"signatureValid"
{-# DEPRECATED vrrsSignatureValid "Use generic-lens or generic-optics with 'signatureValid' instead." #-}

-- | The signing algorithm that was used to verify the signature.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsSigningAlgorithm :: Lens.Lens' VerifyResponse (Core.Maybe Types.SigningAlgorithmSpec)
vrrsSigningAlgorithm = Lens.field @"signingAlgorithm"
{-# DEPRECATED vrrsSigningAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead." #-}

-- | The response status code.
--
-- /Note:/ Consider using 'responseStatus' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsResponseStatus :: Lens.Lens' VerifyResponse Core.Int
vrrsResponseStatus = Lens.field @"responseStatus"
{-# DEPRECATED vrrsResponseStatus "Use generic-lens or generic-optics with 'responseStatus' instead." #-}
