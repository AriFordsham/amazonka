{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-binds   #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -fno-warn-deprecations   #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.KMS.Verify
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Verifies a digital signature that was generated by the 'Sign' operation. 
--
--
-- Verification confirms that an authorized user signed the message with the specified CMK and signing algorithm, and the message hasn't changed since it was signed. If the signature is verified, the value of the @SignatureValid@ field in the response is @True@ . If the signature verification fails, the @Verify@ operation fails with an @KMSInvalidSignatureException@ exception.
-- A digital signature is generated by using the private key in an asymmetric CMK. The signature is verified by using the public key in the same asymmetric CMK. For information about symmetric and asymmetric CMKs, see <https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html Using Symmetric and Asymmetric CMKs> in the /AWS Key Management Service Developer Guide/ .
-- To verify a digital signature, you can use the @Verify@ operation. Specify the same asymmetric CMK, message, and signing algorithm that were used to produce the signature.
-- You can also verify the digital signature by using the public key of the CMK outside of AWS KMS. Use the 'GetPublicKey' operation to download the public key in the asymmetric CMK and then use the public key to verify the signature outside of AWS KMS. The advantage of using the @Verify@ operation is that it is performed within AWS KMS. As a result, it's easy to call, the operation is performed within the FIPS boundary, it is logged in AWS CloudTrail, and you can use key policy and IAM policy to determine who is authorized to use the CMK to verify signatures.
-- The CMK that you use for this operation must be in a compatible key state. For details, see <https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html How Key State Affects Use of a Customer Master Key> in the /AWS Key Management Service Developer Guide/ .
module Network.AWS.KMS.Verify
    (
    -- * Creating a request
      Verify (..)
    , mkVerify
    -- ** Request lenses
    , vKeyId
    , vMessage
    , vSignature
    , vSigningAlgorithm
    , vGrantTokens
    , vMessageType

    -- * Destructuring the response
    , VerifyResponse (..)
    , mkVerifyResponse
    -- ** Response lenses
    , vrrsKeyId
    , vrrsSignatureValid
    , vrrsSigningAlgorithm
    , vrrsResponseStatus
    ) where

import qualified Network.AWS.KMS.Types as Types
import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Core
import qualified Network.AWS.Request as Request
import qualified Network.AWS.Response as Response

-- | /See:/ 'mkVerify' smart constructor.
data Verify = Verify'
  { keyId :: Types.KeyIdType
    -- ^ Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
--
-- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
-- For example:
--
--     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@ 
--
--
--     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@ 
--
--
--     * Alias name: @alias/ExampleAlias@ 
--
--
--     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@ 
--
--
-- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
  , message :: Core.Sensitive Core.Base64
    -- ^ Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
--
-- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.
  , signature :: Core.Base64
    -- ^ The signature that the @Sign@ operation generated.
  , signingAlgorithm :: Types.SigningAlgorithmSpec
    -- ^ The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
  , grantTokens :: Core.Maybe [Types.GrantTokenType]
    -- ^ A list of grant tokens.
--
-- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
  , messageType :: Core.Maybe Types.MessageType
    -- ^ Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
--
-- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
  }
  deriving stock (Core.Eq, Core.Ord, Core.Show, Core.Generic)
  deriving anyclass (Core.Hashable, Core.NFData)

-- | Creates a 'Verify' value with any optional fields omitted.
mkVerify
    :: Types.KeyIdType -- ^ 'keyId'
    -> Core.Sensitive Core.Base64 -- ^ 'message'
    -> Core.Base64 -- ^ 'signature'
    -> Types.SigningAlgorithmSpec -- ^ 'signingAlgorithm'
    -> Verify
mkVerify keyId message signature signingAlgorithm
  = Verify'{keyId, message, signature, signingAlgorithm,
            grantTokens = Core.Nothing, messageType = Core.Nothing}

-- | Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
--
-- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
-- For example:
--
--     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@ 
--
--
--     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@ 
--
--
--     * Alias name: @alias/ExampleAlias@ 
--
--
--     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@ 
--
--
-- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vKeyId :: Lens.Lens' Verify Types.KeyIdType
vKeyId = Lens.field @"keyId"
{-# INLINEABLE vKeyId #-}
{-# DEPRECATED keyId "Use generic-lens or generic-optics with 'keyId' instead"  #-}

-- | Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
--
-- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'message' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessage :: Lens.Lens' Verify (Core.Sensitive Core.Base64)
vMessage = Lens.field @"message"
{-# INLINEABLE vMessage #-}
{-# DEPRECATED message "Use generic-lens or generic-optics with 'message' instead"  #-}

-- | The signature that the @Sign@ operation generated.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'signature' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSignature :: Lens.Lens' Verify Core.Base64
vSignature = Lens.field @"signature"
{-# INLINEABLE vSignature #-}
{-# DEPRECATED signature "Use generic-lens or generic-optics with 'signature' instead"  #-}

-- | The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSigningAlgorithm :: Lens.Lens' Verify Types.SigningAlgorithmSpec
vSigningAlgorithm = Lens.field @"signingAlgorithm"
{-# INLINEABLE vSigningAlgorithm #-}
{-# DEPRECATED signingAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead"  #-}

-- | A list of grant tokens.
--
-- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
--
-- /Note:/ Consider using 'grantTokens' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vGrantTokens :: Lens.Lens' Verify (Core.Maybe [Types.GrantTokenType])
vGrantTokens = Lens.field @"grantTokens"
{-# INLINEABLE vGrantTokens #-}
{-# DEPRECATED grantTokens "Use generic-lens or generic-optics with 'grantTokens' instead"  #-}

-- | Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
--
-- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
--
-- /Note:/ Consider using 'messageType' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessageType :: Lens.Lens' Verify (Core.Maybe Types.MessageType)
vMessageType = Lens.field @"messageType"
{-# INLINEABLE vMessageType #-}
{-# DEPRECATED messageType "Use generic-lens or generic-optics with 'messageType' instead"  #-}

instance Core.ToQuery Verify where
        toQuery _ = Core.pure Core.mempty

instance Core.ToHeaders Verify where
        toHeaders Verify{..}
          = Core.pure ("X-Amz-Target", "TrentService.Verify") Core.<>
              Core.pure ("Content-Type", "application/x-amz-json-1.1")

instance Core.FromJSON Verify where
        toJSON Verify{..}
          = Core.object
              (Core.catMaybes
                 [Core.Just ("KeyId" Core..= keyId),
                  Core.Just ("Message" Core..= message),
                  Core.Just ("Signature" Core..= signature),
                  Core.Just ("SigningAlgorithm" Core..= signingAlgorithm),
                  ("GrantTokens" Core..=) Core.<$> grantTokens,
                  ("MessageType" Core..=) Core.<$> messageType])

instance Core.AWSRequest Verify where
        type Rs Verify = VerifyResponse
        toRequest x@Core.Request{..}
          = Core.Request{Core._rqService = Types.mkServiceConfig,
                         Core._rqMethod = Request.POST, Core._rqPath = "/",
                         Core._rqQuery = Core.toQuery x, Core._rqHeaders = Core.toHeaders x,
                         Core._rqBody = Core.toJSONBody x}
        
        {-# INLINE toRequest #-}
        parseResponse
          = Response.receiveJSON
              (\ s h x ->
                 VerifyResponse' Core.<$>
                   (x Core..:? "KeyId") Core.<*> x Core..:? "SignatureValid" Core.<*>
                     x Core..:? "SigningAlgorithm"
                     Core.<*> Core.pure (Core.fromEnum s))
        
        {-# INLINE parseResponse #-}

-- | /See:/ 'mkVerifyResponse' smart constructor.
data VerifyResponse = VerifyResponse'
  { keyId :: Core.Maybe Types.KeyId
    -- ^ The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
  , signatureValid :: Core.Maybe Core.Bool
    -- ^ A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception. 
  , signingAlgorithm :: Core.Maybe Types.SigningAlgorithmSpec
    -- ^ The signing algorithm that was used to verify the signature.
  , responseStatus :: Core.Int
    -- ^ The response status code.
  }
  deriving stock (Core.Eq, Core.Ord, Core.Read, Core.Show, Core.Generic)
  deriving anyclass (Core.Hashable, Core.NFData)

-- | Creates a 'VerifyResponse' value with any optional fields omitted.
mkVerifyResponse
    :: Core.Int -- ^ 'responseStatus'
    -> VerifyResponse
mkVerifyResponse responseStatus
  = VerifyResponse'{keyId = Core.Nothing,
                    signatureValid = Core.Nothing, signingAlgorithm = Core.Nothing,
                    responseStatus}

-- | The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsKeyId :: Lens.Lens' VerifyResponse (Core.Maybe Types.KeyId)
vrrsKeyId = Lens.field @"keyId"
{-# INLINEABLE vrrsKeyId #-}
{-# DEPRECATED keyId "Use generic-lens or generic-optics with 'keyId' instead"  #-}

-- | A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception. 
--
-- /Note:/ Consider using 'signatureValid' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsSignatureValid :: Lens.Lens' VerifyResponse (Core.Maybe Core.Bool)
vrrsSignatureValid = Lens.field @"signatureValid"
{-# INLINEABLE vrrsSignatureValid #-}
{-# DEPRECATED signatureValid "Use generic-lens or generic-optics with 'signatureValid' instead"  #-}

-- | The signing algorithm that was used to verify the signature.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsSigningAlgorithm :: Lens.Lens' VerifyResponse (Core.Maybe Types.SigningAlgorithmSpec)
vrrsSigningAlgorithm = Lens.field @"signingAlgorithm"
{-# INLINEABLE vrrsSigningAlgorithm #-}
{-# DEPRECATED signingAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead"  #-}

-- | The response status code.
--
-- /Note:/ Consider using 'responseStatus' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrrsResponseStatus :: Lens.Lens' VerifyResponse Core.Int
vrrsResponseStatus = Lens.field @"responseStatus"
{-# INLINEABLE vrrsResponseStatus #-}
{-# DEPRECATED responseStatus "Use generic-lens or generic-optics with 'responseStatus' instead"  #-}
