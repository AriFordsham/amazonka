{-# OPTIONS_GHC -fno-warn-deprecations #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Network.AWS.KMS.Verify
-- Copyright   : (c) 2013-2020 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Verifies a digital signature that was generated by the 'Sign' operation.
--
--
-- Verification confirms that an authorized user signed the message with the specified CMK and signing algorithm, and the message hasn't changed since it was signed. If the signature is verified, the value of the @SignatureValid@ field in the response is @True@ . If the signature verification fails, the @Verify@ operation fails with an @KMSInvalidSignatureException@ exception.
-- A digital signature is generated by using the private key in an asymmetric CMK. The signature is verified by using the public key in the same asymmetric CMK. For information about symmetric and asymmetric CMKs, see <https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html Using Symmetric and Asymmetric CMKs> in the /AWS Key Management Service Developer Guide/ .
-- To verify a digital signature, you can use the @Verify@ operation. Specify the same asymmetric CMK, message, and signing algorithm that were used to produce the signature.
-- You can also verify the digital signature by using the public key of the CMK outside of AWS KMS. Use the 'GetPublicKey' operation to download the public key in the asymmetric CMK and then use the public key to verify the signature outside of AWS KMS. The advantage of using the @Verify@ operation is that it is performed within AWS KMS. As a result, it's easy to call, the operation is performed within the FIPS boundary, it is logged in AWS CloudTrail, and you can use key policy and IAM policy to determine who is authorized to use the CMK to verify signatures.
-- The CMK that you use for this operation must be in a compatible key state. For details, see <https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html How Key State Affects Use of a Customer Master Key> in the /AWS Key Management Service Developer Guide/ .
module Network.AWS.KMS.Verify
  ( -- * Creating a request
    Verify (..),
    mkVerify,

    -- ** Request lenses
    vMessageType,
    vGrantTokens,
    vKeyId,
    vMessage,
    vSignature,
    vSigningAlgorithm,

    -- * Destructuring the response
    VerifyResponse (..),
    mkVerifyResponse,

    -- ** Response lenses
    vrsSigningAlgorithm,
    vrsSignatureValid,
    vrsKeyId,
    vrsResponseStatus,
  )
where

import Network.AWS.KMS.Types
import qualified Network.AWS.Lens as Lens
import qualified Network.AWS.Prelude as Lude
import qualified Network.AWS.Request as Req
import qualified Network.AWS.Response as Res

-- | /See:/ 'mkVerify' smart constructor.
data Verify = Verify'
  { messageType :: Lude.Maybe MessageType,
    grantTokens :: Lude.Maybe [Lude.Text],
    keyId :: Lude.Text,
    message :: Lude.Sensitive Lude.Base64,
    signature :: Lude.Base64,
    signingAlgorithm :: SigningAlgorithmSpec
  }
  deriving stock (Lude.Eq, Lude.Ord, Lude.Show, Lude.Generic)
  deriving anyclass (Lude.Hashable, Lude.NFData)

-- | Creates a value of 'Verify' with the minimum fields required to make a request.
--
-- * 'grantTokens' - A list of grant tokens.
--
-- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
-- * 'keyId' - Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
--
-- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
-- For example:
--
--     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Alias name: @alias/ExampleAlias@
--
--
--     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@
--
--
-- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
-- * 'message' - Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
--
-- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
-- * 'messageType' - Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
--
-- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
-- * 'signature' - The signature that the @Sign@ operation generated.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
-- * 'signingAlgorithm' - The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
mkVerify ::
  -- | 'keyId'
  Lude.Text ->
  -- | 'message'
  Lude.Sensitive Lude.Base64 ->
  -- | 'signature'
  Lude.Base64 ->
  -- | 'signingAlgorithm'
  SigningAlgorithmSpec ->
  Verify
mkVerify pKeyId_ pMessage_ pSignature_ pSigningAlgorithm_ =
  Verify'
    { messageType = Lude.Nothing,
      grantTokens = Lude.Nothing,
      keyId = pKeyId_,
      message = pMessage_,
      signature = pSignature_,
      signingAlgorithm = pSigningAlgorithm_
    }

-- | Tells AWS KMS whether the value of the @Message@ parameter is a message or message digest. The default value, RAW, indicates a message. To indicate a message digest, enter @DIGEST@ .
--
-- /Important:/ Use the @DIGEST@ value only when the value of the @Message@ parameter is a message digest. If you use the @DIGEST@ value with a raw message, the security of the verification operation can be compromised.
--
-- /Note:/ Consider using 'messageType' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessageType :: Lens.Lens' Verify (Lude.Maybe MessageType)
vMessageType = Lens.lens (messageType :: Verify -> Lude.Maybe MessageType) (\s a -> s {messageType = a} :: Verify)
{-# DEPRECATED vMessageType "Use generic-lens or generic-optics with 'messageType' instead." #-}

-- | A list of grant tokens.
--
-- For more information, see <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#grant_token Grant Tokens> in the /AWS Key Management Service Developer Guide/ .
--
-- /Note:/ Consider using 'grantTokens' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vGrantTokens :: Lens.Lens' Verify (Lude.Maybe [Lude.Text])
vGrantTokens = Lens.lens (grantTokens :: Verify -> Lude.Maybe [Lude.Text]) (\s a -> s {grantTokens = a} :: Verify)
{-# DEPRECATED vGrantTokens "Use generic-lens or generic-optics with 'grantTokens' instead." #-}

-- | Identifies the asymmetric CMK that will be used to verify the signature. This must be the same CMK that was used to generate the signature. If you specify a different CMK, the signature verification fails.
--
-- To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with @"alias/"@ . To specify a CMK in a different AWS account, you must use the key ARN or alias ARN.
-- For example:
--
--     * Key ID: @1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Key ARN: @arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab@
--
--
--     * Alias name: @alias/ExampleAlias@
--
--
--     * Alias ARN: @arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias@
--
--
-- To get the key ID and key ARN for a CMK, use 'ListKeys' or 'DescribeKey' . To get the alias name and alias ARN, use 'ListAliases' .
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vKeyId :: Lens.Lens' Verify Lude.Text
vKeyId = Lens.lens (keyId :: Verify -> Lude.Text) (\s a -> s {keyId = a} :: Verify)
{-# DEPRECATED vKeyId "Use generic-lens or generic-optics with 'keyId' instead." #-}

-- | Specifies the message that was signed. You can submit a raw message of up to 4096 bytes, or a hash digest of the message. If you submit a digest, use the @MessageType@ parameter with a value of @DIGEST@ .
--
-- If the message specified here is different from the message that was signed, the signature verification fails. A message and its hash digest are considered to be the same message.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'message' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vMessage :: Lens.Lens' Verify (Lude.Sensitive Lude.Base64)
vMessage = Lens.lens (message :: Verify -> Lude.Sensitive Lude.Base64) (\s a -> s {message = a} :: Verify)
{-# DEPRECATED vMessage "Use generic-lens or generic-optics with 'message' instead." #-}

-- | The signature that the @Sign@ operation generated.--
-- /Note:/ This 'Lens' automatically encodes and decodes Base64 data.
-- The underlying isomorphism will encode to Base64 representation during
-- serialisation, and decode from Base64 representation during deserialisation.
-- This 'Lens' accepts and returns only raw unencoded data.
--
-- /Note:/ Consider using 'signature' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSignature :: Lens.Lens' Verify Lude.Base64
vSignature = Lens.lens (signature :: Verify -> Lude.Base64) (\s a -> s {signature = a} :: Verify)
{-# DEPRECATED vSignature "Use generic-lens or generic-optics with 'signature' instead." #-}

-- | The signing algorithm that was used to sign the message. If you submit a different algorithm, the signature verification fails.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vSigningAlgorithm :: Lens.Lens' Verify SigningAlgorithmSpec
vSigningAlgorithm = Lens.lens (signingAlgorithm :: Verify -> SigningAlgorithmSpec) (\s a -> s {signingAlgorithm = a} :: Verify)
{-# DEPRECATED vSigningAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead." #-}

instance Lude.AWSRequest Verify where
  type Rs Verify = VerifyResponse
  request = Req.postJSON kmsService
  response =
    Res.receiveJSON
      ( \s h x ->
          VerifyResponse'
            Lude.<$> (x Lude..?> "SigningAlgorithm")
            Lude.<*> (x Lude..?> "SignatureValid")
            Lude.<*> (x Lude..?> "KeyId")
            Lude.<*> (Lude.pure (Lude.fromEnum s))
      )

instance Lude.ToHeaders Verify where
  toHeaders =
    Lude.const
      ( Lude.mconcat
          [ "X-Amz-Target" Lude.=# ("TrentService.Verify" :: Lude.ByteString),
            "Content-Type"
              Lude.=# ("application/x-amz-json-1.1" :: Lude.ByteString)
          ]
      )

instance Lude.ToJSON Verify where
  toJSON Verify' {..} =
    Lude.object
      ( Lude.catMaybes
          [ ("MessageType" Lude..=) Lude.<$> messageType,
            ("GrantTokens" Lude..=) Lude.<$> grantTokens,
            Lude.Just ("KeyId" Lude..= keyId),
            Lude.Just ("Message" Lude..= message),
            Lude.Just ("Signature" Lude..= signature),
            Lude.Just ("SigningAlgorithm" Lude..= signingAlgorithm)
          ]
      )

instance Lude.ToPath Verify where
  toPath = Lude.const "/"

instance Lude.ToQuery Verify where
  toQuery = Lude.const Lude.mempty

-- | /See:/ 'mkVerifyResponse' smart constructor.
data VerifyResponse = VerifyResponse'
  { signingAlgorithm ::
      Lude.Maybe SigningAlgorithmSpec,
    signatureValid :: Lude.Maybe Lude.Bool,
    keyId :: Lude.Maybe Lude.Text,
    responseStatus :: Lude.Int
  }
  deriving stock
    ( Lude.Eq,
      Lude.Ord,
      Lude.Read,
      Lude.Show,
      Lude.Generic
    )
  deriving anyclass (Lude.Hashable, Lude.NFData)

-- | Creates a value of 'VerifyResponse' with the minimum fields required to make a request.
--
-- * 'keyId' - The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
-- * 'responseStatus' - The response status code.
-- * 'signatureValid' - A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception.
-- * 'signingAlgorithm' - The signing algorithm that was used to verify the signature.
mkVerifyResponse ::
  -- | 'responseStatus'
  Lude.Int ->
  VerifyResponse
mkVerifyResponse pResponseStatus_ =
  VerifyResponse'
    { signingAlgorithm = Lude.Nothing,
      signatureValid = Lude.Nothing,
      keyId = Lude.Nothing,
      responseStatus = pResponseStatus_
    }

-- | The signing algorithm that was used to verify the signature.
--
-- /Note:/ Consider using 'signingAlgorithm' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrsSigningAlgorithm :: Lens.Lens' VerifyResponse (Lude.Maybe SigningAlgorithmSpec)
vrsSigningAlgorithm = Lens.lens (signingAlgorithm :: VerifyResponse -> Lude.Maybe SigningAlgorithmSpec) (\s a -> s {signingAlgorithm = a} :: VerifyResponse)
{-# DEPRECATED vrsSigningAlgorithm "Use generic-lens or generic-optics with 'signingAlgorithm' instead." #-}

-- | A Boolean value that indicates whether the signature was verified. A value of @True@ indicates that the @Signature@ was produced by signing the @Message@ with the specified @KeyID@ and @SigningAlgorithm.@ If the signature is not verified, the @Verify@ operation fails with a @KMSInvalidSignatureException@ exception.
--
-- /Note:/ Consider using 'signatureValid' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrsSignatureValid :: Lens.Lens' VerifyResponse (Lude.Maybe Lude.Bool)
vrsSignatureValid = Lens.lens (signatureValid :: VerifyResponse -> Lude.Maybe Lude.Bool) (\s a -> s {signatureValid = a} :: VerifyResponse)
{-# DEPRECATED vrsSignatureValid "Use generic-lens or generic-optics with 'signatureValid' instead." #-}

-- | The Amazon Resource Name (<https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN key ARN> ) of the asymmetric CMK that was used to verify the signature.
--
-- /Note:/ Consider using 'keyId' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrsKeyId :: Lens.Lens' VerifyResponse (Lude.Maybe Lude.Text)
vrsKeyId = Lens.lens (keyId :: VerifyResponse -> Lude.Maybe Lude.Text) (\s a -> s {keyId = a} :: VerifyResponse)
{-# DEPRECATED vrsKeyId "Use generic-lens or generic-optics with 'keyId' instead." #-}

-- | The response status code.
--
-- /Note:/ Consider using 'responseStatus' with <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/generic-optics generic-optics> instead.
vrsResponseStatus :: Lens.Lens' VerifyResponse Lude.Int
vrsResponseStatus = Lens.lens (responseStatus :: VerifyResponse -> Lude.Int) (\s a -> s {responseStatus = a} :: VerifyResponse)
{-# DEPRECATED vrsResponseStatus "Use generic-lens or generic-optics with 'responseStatus' instead." #-}
